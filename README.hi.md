# एपी --`auto-pager`

एपी एक शेल उपयोगिता है जो अन्य शेल कमांड के आउटपुट को स्वचालित रूप से इंटरैक्टिव पेज-फ़्लिपिंग मोड में प्रवेश करने की अनुमति देती है।

एपी में दो भाग होते हैं, गो में लिखा गया एक बाइनरी प्रोग्राम जो कमांड के आउटपुट को कैप्चर करता है और पेज-फ़्लिपिंग का समर्थन करता है, और शेल स्क्रिप्ट का एक सेट जो कमांड की उपयोगकर्ता-निर्दिष्ट सूची के लिए समान नाम के साथ एक रैपर बनाता है।

रैप के बाद कमांड का उपयोग पहले जैसा ही है, और इससे उपयोगकर्ता की आदतें नहीं बदलनी चाहिए या कोई समस्या नहीं होनी चाहिए।

इसे अन्य भाषाओं में पढ़ें:[अंग्रेज़ी](README.en.md),[सरलीकृत चीनी](README.md),[परंपरागत चीनी](README.zh-TW.md),[अरबी](README.ar.md),[फ़्रेंच](README.fr.md),[नहीं](README.hi.md)

एपी एक शेल टूल है जो अन्य शेल कमांड के आउटपुट को स्वचालित रूप से इंटरैक्टिव पेज-टर्निंग मोड में प्रवेश करने में सक्षम बनाता है।

एपी में दो भाग होते हैं, गो भाषा में लिखा गया एक बाइनरी प्रोग्राम, जो कमांड के आउटपुट को कैप्चर करने और पेज टर्निंग का समर्थन करने के लिए जिम्मेदार है,
और उपयोगकर्ता-निर्दिष्ट कमांड लिस्टिंग के लिए समान नाम के रैपर बनाने के लिए जिम्मेदार शेल स्क्रिप्ट का एक सेट।

经过 wrap 之后的命令用法与原来相同，不应当改变用户操作习惯，不会给用户造成困扰。

## स्थापित करना

    go install github.com/flw-cn/ap@master

## विन्यास

-   `bash`(#दे घुमा के)
-   `fish`(#`fish`)
-   `zsh`(#`zsh`)

### दे घुमा के

तुम्हारी ओर`~/.bashrc`इसमें निम्नलिखित जोड़ें:

```sh
eval "$(ap --bash)"
```

एपी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS=(go cargo make)
eval "$(ap --bash)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_EXTRA=(ps last)
eval "$(ap --bash)"
```

इसके अलावा एपी का भी उपयोग किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के अंतर्गत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS_WITH_GRC=(ps last dig diff)
eval "$(ap --bash)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_WITH_GRC_EXTRA=(ps last)
eval "$(ap --bash)"
```

इसके अतिरिक्त, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए पंक्तियों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
AUTO_PAGER_MIN_HEIGHT=30        # 输出超过 30 行时才开始分页
eval "$(ap --bash)"
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई का प्रतिशत दर्शाता है:

```sh
AUTO_PAGER_MIN_HEIGHT='-50'     # 输出超过终端窗口高度的 50% 时才开始分页
eval "$(ap --bash)"
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

### `fish`

तुम्हारी ओर`~/.config/fish/config.fish`इसमें निम्नलिखित जोड़ें:

```sh
ap --fish | source
```

एपी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
set AUTO_PAGER_CMDS go cargo make
ap --fish | source
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
set AUTO_PAGER_CMDS_EXTRA ps last
ap --fish | source
```

इसके अलावा एपी का भी उपयोग किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के अंतर्गत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
set AUTO_PAGER_CMDS_WITH_GRC ps last dig diff
ap --fish | source
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
set AUTO_PAGER_CMDS_WITH_GRC_EXTRA ps last
ap --fish | source
```

इसके अतिरिक्त, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए पंक्तियों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
set AUTO_PAGER_MIN_HEIGHT 30        # 输出超过 30 行时才开始分页
ap --fish | source
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई का प्रतिशत दर्शाता है:

```sh
set AUTO_PAGER_MIN_HEIGHT -50     # 输出超过终端窗口高度的 50% 时才开始分页
ap --fish | source
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

### `zsh`

तुम्हारी ओर`~/.zshrc`इसमें निम्नलिखित जोड़ें:

```sh
eval "$(ap --zsh)"
```

एपी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS=(go cargo make)
eval "$(ap --zsh)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_EXTRA=(ps last)
eval "$(ap --zsh)"
```

इसके अलावा एपी का भी उपयोग किया जा सकता है[जीआरसी](https://github.com/garabik/grc)एक साथ काम करते हुए, macOS के अंतर्गत Homebrew का उपयोग करके grc स्थापित किया जा सकता है:

```sh
brew install grc
```

एपी + जीआरसी डिफ़ॉल्ट रूप से कमांड के एक बैच को लपेटता है। यदि आप संतुष्ट नहीं हैं, तो आप पर्यावरण चर के माध्यम से पुनः अनुकूलित कर सकते हैं:

```sh
AUTO_PAGER_CMDS_WITH_GRC=(ps last dig diff)
eval "$(ap --zsh)"
```

या बस डिफ़ॉल्ट सूची के शीर्ष पर नए आदेश जोड़ें:

```sh
AUTO_PAGER_CMDS_WITH_GRC_EXTRA=(ps last)
eval "$(ap --zsh)"
```

इसके अतिरिक्त, पर्यावरण चर`$AUTO_PAGER_MIN_HEIGHT`आप पेजिंग शुरू करने के लिए पंक्तियों की न्यूनतम संख्या को नियंत्रित कर सकते हैं:

```sh
AUTO_PAGER_MIN_HEIGHT=30        # 输出超过 30 行时才开始分页
eval "$(ap --zsh)"
```

यदि ऋणात्मक संख्या के रूप में कॉन्फ़िगर किया गया है, तो यह टर्मिनल विंडो की ऊंचाई का प्रतिशत दर्शाता है:

```sh
AUTO_PAGER_MIN_HEIGHT='-50'     # 输出超过终端窗口高度的 50% 时才开始分页
eval "$(ap --zsh)"
```

यदि निर्दिष्ट नहीं है`AUTO_PAGER_MIN_HEIGHT`,डिफ़ॉल्ट है`-80`,अभी`80%`。

## उपयोग

जिन कमांडों को एपी रैप किया गया है उन्हें हमेशा की तरह उपयोग करने की आवश्यकता है।
यदि बहुत अधिक आउटपुट है, तो पर्यावरण चर स्वचालित रूप से कॉल किया जाएगा`$PAGER`निर्दिष्ट पेजर पेजिनेशन करता है।

अपने अगर`$PAGER`वेरिएबल विशेष होते हैं और उन्हें एपी में अनुकूलित नहीं किया जा सकता है, आप पर्यावरण वेरिएबल का भी उपयोग कर सकते हैं`$AP_PAGER`एपी के लिए अलग से पेजर सेट करें।

अगर`$AP_PAGER`और`$PAGER`न तो निर्दिष्ट है, तो`less -Fr`。

निम्नलिखित स्थितियाँ पेजर प्रारंभ नहीं करेंगी:

-   जब आउटपुट सामग्री बहुत छोटी हो, तो देखें`$AUTO_PAGER_MIN_HEIGHT`。
-   जब एपी यह पता लगाता है कि कमांड आउटपुट में शामिल है`ESC [?1049h`अनुक्रम में, कमांड को इस समय एक पूर्ण-स्क्रीन एप्लिकेशन माना जाता है।
-   जब कमांड ने निष्पादन पूरा नहीं किया है। कमांड निष्पादन पूरा होने तक पेजर प्रारंभ नहीं होगा।
    -   `ping`और`tcpdump`ऐसे आदेशों को पहले दबाना होगा`Ctrl-C`कमांड समाप्त होने तक पेजिंग प्रारंभ नहीं होती है।
    -   `python`और`gdb`ऐसे कमांड को पेजिंग शुरू करने से पहले कमांड के बाहर निकलने का इंतजार करना होगा।

## आम समस्या

-   क्या यह कमांड के रंगीन आउटपुट को प्रभावित करेगा?
    -   नहीं होगा।
-   क्या एक कमांड जो टर्मिनल का पता लगाता है और टर्मिनल और गैर-टर्मिनल मोड के लिए अलग-अलग आउटपुट प्रदान करता है, उसका आउटपुट बदल देता है?
    -   नहीं होगा।
-   यदि मुझे संदेह है कि एपी किसी कमांड के आउटपुट को प्रभावित कर रहा है तो मैं इसका निदान कैसे करूँ?
    -   आप इसका उपयोग कर सकते हैं`command foo`अंजाम देना`foo`, ताकि एपी को कॉल न किया जाए।
-   अगर मैं आदतन एपी कमांड के बाद जोड़ता हूं`| less`, क्या कुछ गलत हो जाएगा?
    -   नहीं होगा।
-   क्या कोई एपी कमांड अपने आउटपुट को रीडायरेक्ट भी कर सकता है?
    -   कर सकना।
-   क्या AP'D आदेशों का स्वतः पूर्ण होना टूट जाएगा?
    -   नहीं होगा।
-   एपी समर्थन जैसे`python`、`gdb`ऐसा इंटरैक्टिव एप्लिकेशन?
    -   सहायता। हालाँकि, चूंकि ये एप्लिकेशन कुछ नियंत्रण वर्णों को आउटपुट करते हैं, पेजिनेशन के बाद आप जो सामग्री देखते हैं वह थोड़ी गड़बड़ हो सकती है।
-   एपी समर्थन जैसे`htop`、`vim`ऐसा पूर्ण स्क्रीन एप्लिकेशन?
    -   इसे कैसे कहें, यह वैसे भी गलत नहीं हो सकता, लेकिन मैं समझ नहीं पा रहा हूं कि एपी को उनके साथ जोड़ने का व्यावहारिक मतलब क्या है।
